package pocket.ledger.repository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertAll;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import pocket.ledger.enums.TransactionType;
import pocket.ledger.model.Transaction;
import pocket.ledger.util.Page;
import pocket.ledger.util.PageRequest;

@DisplayName("TransactionRepositoryImpl Unit Tests")
class TransactionRepositoryImplTest {

  private TransactionRepositoryImpl repository;

  @BeforeEach
  void setUp() {
    repository = new TransactionRepositoryImpl();
  }

  @Nested
  @DisplayName("Transaction Save Operations")
  class SaveOperations {

    @Test
    @DisplayName("Should save transaction with auto-generated ID")
    void shouldSaveTransactionWithAutoGeneratedId() {
      Transaction transaction = createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT);

      Transaction savedTransaction = repository.save(transaction);

      assertAll(
          () -> assertThat(savedTransaction.getId()).isNotNull(),
          () -> assertThat(savedTransaction.getId()).isEqualTo(1L),
          () -> assertThat(savedTransaction.getAmount()).isEqualTo(BigDecimal.valueOf(100)),
          () -> assertThat(savedTransaction.getType()).isEqualTo(TransactionType.DEPOSIT),
          () -> assertThat(savedTransaction.getLastModifiedDate()).isNotNull());
    }

    @Test
    @DisplayName("Should preserve existing ID when saving")
    void shouldPreserveExistingIdWhenSaving() {
      Transaction transaction = createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT);
      transaction.setId(999L);

      Transaction savedTransaction = repository.save(transaction);

      assertThat(savedTransaction.getId()).isEqualTo(999L);
    }

    @Test
    @DisplayName("Should update lastModifiedDate on save")
    void shouldUpdateLastModifiedDateOnSave() {
      Transaction transaction = createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT);
      LocalDateTime beforeSave = LocalDateTime.now().minusSeconds(1);

      Transaction savedTransaction = repository.save(transaction);

      assertThat(savedTransaction.getLastModifiedDate()).isAfter(beforeSave);
    }

    @Test
    @DisplayName("Should generate sequential IDs for multiple transactions")
    void shouldGenerateSequentialIds() {
      Transaction transaction1 =
          createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT);
      Transaction transaction2 =
          createTransaction(BigDecimal.valueOf(200), TransactionType.WITHDRAWAL);

      Transaction saved1 = repository.save(transaction1);
      Transaction saved2 = repository.save(transaction2);

      assertAll(
          () -> assertThat(saved1.getId()).isEqualTo(1L),
          () -> assertThat(saved2.getId()).isEqualTo(2L));
    }
  }

  @Nested
  @DisplayName("Balance Calculation")
  class BalanceCalculation {

    @Test
    @DisplayName("Should start with zero balance")
    void shouldStartWithZeroBalance() {
      BigDecimal balance = repository.calculateBalance();

      assertThat(balance).isEqualTo(BigDecimal.ZERO);
    }

    @Test
    @DisplayName("Should increase balance for deposits")
    void shouldIncreaseBalanceForDeposits() {
      Transaction deposit = createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT);

      repository.save(deposit);

      assertThat(repository.calculateBalance()).isEqualTo(BigDecimal.valueOf(100));
    }

    @Test
    @DisplayName("Should decrease balance for withdrawals")
    void shouldDecreaseBalanceForWithdrawals() {
      repository.save(createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT));
      Transaction withdrawal =
          createTransaction(BigDecimal.valueOf(30), TransactionType.WITHDRAWAL);

      repository.save(withdrawal);

      assertThat(repository.calculateBalance()).isEqualTo(BigDecimal.valueOf(70));
    }

    @Test
    @DisplayName("Should calculate balance correctly for multiple transactions")
    void shouldCalculateBalanceForMultipleTransactions() {
      repository.save(createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT));
      repository.save(createTransaction(BigDecimal.valueOf(50), TransactionType.DEPOSIT));
      repository.save(createTransaction(BigDecimal.valueOf(30), TransactionType.WITHDRAWAL));
      repository.save(createTransaction(BigDecimal.valueOf(20), TransactionType.WITHDRAWAL));

      BigDecimal balance = repository.calculateBalance();

      assertThat(balance).isEqualTo(BigDecimal.valueOf(100));
    }

    @Test
    @DisplayName("Should handle decimal amounts correctly")
    void shouldHandleDecimalAmountsCorrectly() {
      repository.save(createTransaction(new BigDecimal("100.50"), TransactionType.DEPOSIT));
      repository.save(createTransaction(new BigDecimal("25.25"), TransactionType.WITHDRAWAL));

      BigDecimal balance = repository.calculateBalance();

      assertThat(balance).isEqualTo(new BigDecimal("75.25"));
    }
  }

  @Nested
  @DisplayName("Find Operations")
  class FindOperations {

    @Test
    @DisplayName("Should find transaction by ID")
    void shouldFindTransactionById() {
      Transaction saved =
          repository.save(createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT));

      Optional<Transaction> found = repository.findById(saved.getId());

      assertAll(
          () -> assertThat(found).isPresent(),
          () -> assertThat(found.get().getId()).isEqualTo(saved.getId()),
          () -> assertThat(found.get().getAmount()).isEqualTo(BigDecimal.valueOf(100)));
    }

    @Test
    @DisplayName("Should return empty for non-existent ID")
    void shouldReturnEmptyForNonExistentId() {
      Optional<Transaction> found = repository.findById(999L);

      assertThat(found).isEmpty();
    }
  }

  @Nested
  @DisplayName("Pagination")
  class PaginationTests {

    @BeforeEach
    void setUpTransactions() {
      for (int i = 1; i <= 5; i++) {
        Transaction transaction =
            createTransaction(BigDecimal.valueOf(i * 10), TransactionType.DEPOSIT);
        repository.save(transaction);
        try {
          Thread.sleep(1);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }

    @Test
    @DisplayName("Should return all transactions with correct pagination")
    void shouldReturnAllTransactionsWithPagination() {
      PageRequest pageRequest = PageRequest.of(0, 3);

      Page<Transaction> page = repository.findAll(pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).hasSize(3),
          () -> assertThat(page.getTotalElements()).isEqualTo(5),
          () -> assertThat(page.getTotalPages()).isEqualTo(2),
          () -> assertThat(page.isFirst()).isTrue(),
          () -> assertThat(page.isLast()).isFalse());
    }

    @Test
    @DisplayName("Should return second page correctly")
    void shouldReturnSecondPageCorrectly() {
      PageRequest pageRequest = PageRequest.of(1, 3);

      Page<Transaction> page = repository.findAll(pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).hasSize(2),
          () -> assertThat(page.getTotalElements()).isEqualTo(5),
          () -> assertThat(page.getTotalPages()).isEqualTo(2),
          () -> assertThat(page.isFirst()).isFalse(),
          () -> assertThat(page.isLast()).isTrue());
    }

    @Test
    @DisplayName("Should return empty page when page number exceeds total pages")
    void shouldReturnEmptyPageWhenPageNumberExceedsTotalPages() {
      PageRequest pageRequest = PageRequest.of(10, 3);

      Page<Transaction> page = repository.findAll(pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).isEmpty(),
          () -> assertThat(page.getTotalElements()).isEqualTo(5),
          () -> assertThat(page.getTotalPages()).isEqualTo(2));
    }

    @Test
    @DisplayName("Should sort transactions by creation date descending")
    void shouldSortTransactionsByCreationDateDescending() {
      PageRequest pageRequest = PageRequest.of(0, 5);

      Page<Transaction> page = repository.findAll(pageRequest);

      List<Transaction> transactions = page.getContent();
      for (int i = 0; i < transactions.size() - 1; i++) {
        LocalDateTime current = transactions.get(i).getCreatedDate();
        LocalDateTime next = transactions.get(i + 1).getCreatedDate();
        assertThat(current).isAfterOrEqualTo(next);
      }
    }
  }

  @Nested
  @DisplayName("Date Range Filtering")
  class DateRangeFiltering {

    private LocalDateTime baseTime;
    private Transaction transaction1;
    private Transaction transaction2;
    private Transaction transaction3;

    @BeforeEach
    void setUpTransactionsWithSpecificDates() {
      baseTime = LocalDateTime.of(2024, 1, 1, 10, 0, 0);

      transaction1 =
          createTransactionWithDate(BigDecimal.valueOf(100), TransactionType.DEPOSIT, baseTime);
      transaction2 =
          createTransactionWithDate(
              BigDecimal.valueOf(200), TransactionType.WITHDRAWAL, baseTime.plusHours(1));
      transaction3 =
          createTransactionWithDate(
              BigDecimal.valueOf(300), TransactionType.DEPOSIT, baseTime.plusHours(2));

      repository.save(transaction1);
      repository.save(transaction2);
      repository.save(transaction3);
    }

    @Test
    @DisplayName("Should find transactions within date range")
    void shouldFindTransactionsWithinDateRange() {
      LocalDateTime startDate = baseTime.minusMinutes(30);
      LocalDateTime endDate = baseTime.plusMinutes(90);
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page = repository.findByDateRange(startDate, endDate, pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).hasSize(2),
          () ->
              assertThat(page.getContent())
                  .extracting("amount")
                  .containsExactly(BigDecimal.valueOf(200), BigDecimal.valueOf(100)));
    }

    @Test
    @DisplayName("Should return empty page when no transactions in date range")
    void shouldReturnEmptyPageWhenNoTransactionsInDateRange() {
      LocalDateTime startDate = baseTime.minusHours(2);
      LocalDateTime endDate = baseTime.minusHours(1);
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page = repository.findByDateRange(startDate, endDate, pageRequest);

      assertThat(page.getContent()).isEmpty();
    }

    @Test
    @DisplayName("Should include boundary dates")
    void shouldIncludeBoundaryDates() {
      LocalDateTime startDate = baseTime;
      LocalDateTime endDate = baseTime.plusHours(2);
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page = repository.findByDateRange(startDate, endDate, pageRequest);

      assertThat(page.getContent()).hasSize(3);
    }

    @Test
    @DisplayName("Should handle edge cases with extreme date ranges")
    void shouldHandleEdgeCasesWithExtremeDateRanges() {
      LocalDateTime startDate = LocalDateTime.MIN;
      LocalDateTime endDate = LocalDateTime.MAX;
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page = repository.findByDateRange(startDate, endDate, pageRequest);

      assertThat(page.getContent()).hasSize(3);
    }

    @Test
    @DisplayName("Should handle exact timestamp boundaries")
    void shouldHandleExactTimestampBoundaries() {
      LocalDateTime exactTime = transaction2.getCreatedDate();
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page = repository.findByDateRange(exactTime, exactTime, pageRequest);

      assertThat(page.getContent()).hasSize(1);
      assertThat(page.getContent().get(0).getAmount()).isEqualTo(BigDecimal.valueOf(200));
    }
  }

  @Nested
  @DisplayName("Type Filtering")
  class TypeFiltering {

    @BeforeEach
    void setUpTransactionsWithDifferentTypes() {
      repository.save(createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT));
      repository.save(createTransaction(BigDecimal.valueOf(200), TransactionType.WITHDRAWAL));
      repository.save(createTransaction(BigDecimal.valueOf(300), TransactionType.DEPOSIT));
      repository.save(createTransaction(BigDecimal.valueOf(400), TransactionType.WITHDRAWAL));
    }

    @Test
    @DisplayName("Should find only deposit transactions")
    void shouldFindOnlyDepositTransactions() {
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page = repository.findByType(TransactionType.DEPOSIT, pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).hasSize(2),
          () -> assertThat(page.getContent()).allMatch(t -> t.getType() == TransactionType.DEPOSIT),
          () ->
              assertThat(page.getContent())
                  .extracting("amount")
                  .containsExactly(BigDecimal.valueOf(300), BigDecimal.valueOf(100)));
    }

    @Test
    @DisplayName("Should find only withdrawal transactions")
    void shouldFindOnlyWithdrawalTransactions() {
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page = repository.findByType(TransactionType.WITHDRAWAL, pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).hasSize(2),
          () ->
              assertThat(page.getContent())
                  .allMatch(t -> t.getType() == TransactionType.WITHDRAWAL),
          () ->
              assertThat(page.getContent())
                  .extracting("amount")
                  .containsExactly(BigDecimal.valueOf(400), BigDecimal.valueOf(200)));
    }
  }

  @Nested
  @DisplayName("Combined Date Range and Type Filtering")
  class CombinedFiltering {

    private LocalDateTime baseTime;

    @BeforeEach
    void setUpTransactionsForCombinedFiltering() {
      baseTime = LocalDateTime.of(2024, 1, 1, 10, 0, 0);

      repository.save(
          createTransactionWithDate(BigDecimal.valueOf(100), TransactionType.DEPOSIT, baseTime));
      repository.save(
          createTransactionWithDate(
              BigDecimal.valueOf(200), TransactionType.WITHDRAWAL, baseTime.plusMinutes(30)));
      repository.save(
          createTransactionWithDate(
              BigDecimal.valueOf(300), TransactionType.DEPOSIT, baseTime.plusHours(1)));
      repository.save(
          createTransactionWithDate(
              BigDecimal.valueOf(400), TransactionType.WITHDRAWAL, baseTime.plusHours(2)));
    }

    @Test
    @DisplayName("Should find deposits within date range")
    void shouldFindDepositsWithinDateRange() {
      LocalDateTime startDate = baseTime.minusMinutes(10);
      LocalDateTime endDate = baseTime.plusMinutes(70);
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page =
          repository.findByDateRangeAndType(
              startDate, endDate, TransactionType.DEPOSIT, pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).hasSize(2),
          () -> assertThat(page.getContent()).allMatch(t -> t.getType() == TransactionType.DEPOSIT),
          () ->
              assertThat(page.getContent())
                  .extracting("amount")
                  .containsExactly(BigDecimal.valueOf(300), BigDecimal.valueOf(100)));
    }

    @Test
    @DisplayName("Should find withdrawals within date range")
    void shouldFindWithdrawalsWithinDateRange() {
      LocalDateTime startDate = baseTime.plusMinutes(20);
      LocalDateTime endDate = baseTime.plusHours(3);
      PageRequest pageRequest = PageRequest.of(0, 10);

      Page<Transaction> page =
          repository.findByDateRangeAndType(
              startDate, endDate, TransactionType.WITHDRAWAL, pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).hasSize(2),
          () ->
              assertThat(page.getContent())
                  .allMatch(t -> t.getType() == TransactionType.WITHDRAWAL),
          () ->
              assertThat(page.getContent())
                  .extracting("amount")
                  .containsExactly(BigDecimal.valueOf(400), BigDecimal.valueOf(200)));
    }
  }

  @Nested
  @DisplayName("Transaction Count")
  class TransactionCount {

    @Test
    @DisplayName("Should return zero count for empty repository")
    void shouldReturnZeroCountForEmptyRepository() {
      Long count = repository.countTransactions();

      assertThat(count).isEqualTo(0L);
    }

    @Test
    @DisplayName("Should return correct count after adding transactions")
    void shouldReturnCorrectCountAfterAddingTransactions() {
      repository.save(createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT));
      repository.save(createTransaction(BigDecimal.valueOf(200), TransactionType.WITHDRAWAL));

      Long count = repository.countTransactions();

      assertThat(count).isEqualTo(2L);
    }
  }

  @Nested
  @DisplayName("Edge Cases")
  class EdgeCases {

    @Test
    @DisplayName("Should handle very large amounts")
    void shouldHandleVeryLargeAmounts() {
      BigDecimal largeAmount = new BigDecimal("999999999999999999.99");
      Transaction transaction = createTransaction(largeAmount, TransactionType.DEPOSIT);

      Transaction saved = repository.save(transaction);

      assertAll(
          () -> assertThat(saved.getAmount()).isEqualTo(largeAmount),
          () -> assertThat(repository.calculateBalance()).isEqualTo(largeAmount));
    }

    @Test
    @DisplayName("Should handle very small amounts")
    void shouldHandleVerySmallAmounts() {
      BigDecimal smallAmount = new BigDecimal("0.01");
      Transaction transaction = createTransaction(smallAmount, TransactionType.DEPOSIT);

      Transaction saved = repository.save(transaction);

      assertAll(
          () -> assertThat(saved.getAmount()).isEqualTo(smallAmount),
          () -> assertThat(repository.calculateBalance()).isEqualTo(smallAmount));
    }

    @Test
    @DisplayName("Should handle zero page size gracefully")
    void shouldHandleZeroPageSizeGracefully() {
      repository.save(createTransaction(BigDecimal.valueOf(100), TransactionType.DEPOSIT));
      PageRequest pageRequest = PageRequest.of(0, 0);

      Page<Transaction> page = repository.findAll(pageRequest);

      assertAll(
          () -> assertThat(page.getContent()).isEmpty(),
          () -> assertThat(page.getTotalElements()).isEqualTo(1));
    }
  }

  private Transaction createTransaction(BigDecimal amount, TransactionType type) {
    return new Transaction(amount, type, "Test transaction");
  }

  private Transaction createTransactionWithDate(
      BigDecimal amount, TransactionType type, LocalDateTime createdDate) {
    Transaction transaction = new Transaction(amount, type, "Test transaction");
    transaction.setCreatedDate(createdDate);
    return transaction;
  }
}
